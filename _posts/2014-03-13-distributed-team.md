---
title: The Distributed Team
author: mnash
excerpt: "You don't need to restrict your team to only the developers within a commute distance of your location: Build a distributed team!"
layout: post
permalink: /distributed-team/
categories:
  - Software Craftsmanship
---
A lot has been said in the last few years about <a href="http://en.wikipedia.org/wiki/Distributed_computing" target="_new">distributed computing</a> &#8211; that is, taking a problem and splitting it up into pieces that more than one machine (virtual or otherwise) can work on at once. It&#8217;s a powerfulÂ technique, but it doesn&#8217;t only work on software: your **team** can be distributed as well.

The co-located software team has it&#8217;s own unique problems, one of which is that many of the supposed advantages of co-location only work fully in what is called an &#8220;open plan&#8221; arrangement. Unfortunately, open plan arrangements are *terrible* for software development, as study after study have proven. Interestingly, the more experienced and effective your developers are, the *less* the open plan arrangement works, in fact.

### Ramping Up

There&#8217;s a fine art to building a team to do expert software development, and it&#8217;s not easy. Adding new team members is often a recipe for going *slower*, not faster. You not only need to get the new team member up to speed on the specific problem, but you have to try to make sure you&#8217;ve got the right kind of developer, one who won&#8217;t slow down a project even once they&#8217;re up to speed, or force the whole team to try to work at a lower level of technical expertise so they can keep up.

Of course, with traditionally co-located teams, you&#8217;re limited to the developers you can add. They have to be near enough to commute to your offices (where you must have space to have them). When you&#8217;re dealing with high-end software projects, this is a limited supply, even if you&#8217;re fortunate enough to be in a developer-rich location. Not all developers you might want to work with live in your city, of course.

What if you could build a development team of the best people for the project, no matter where they happened to live? That&#8217;s what we call a Distributed Team, and it&#8217;s a very different thing than a co-located development group, with different needs and different advantages.

A distributed team is one where some or all of the team members are not in close physical proximity to each other. They might be in a different room, in a different building, city, or nation.

This gives you a pool of, effectively, all developers in the world to choose from. The probability of locating the *right* team members can be considerably higher in this case, although finding them is still a challenge.

### What&#8217;s in it for you?

As Jason Fried, in his book &#8220;Remote&#8221;, describes, there are huge potential advantages in this approach. He also touches on the fact that the organization can benefit hugely as well, and that&#8217;s what I&#8217;d like to concentrate on here for a moment. If your company decides to embrace remote teams, it has the opportunity to create a group that goes past the limits of geography, yes, but it&#8217;s more than that.

Because the management dynamic of a remote team has to change, it is necessary to judge team members input by *results* not by duration. In other words, if you can&#8217;t see butts in a chair for eight hours a day, you need to find a different way of determining if things are getting done &#8211; by measuring the results directly. Suddenly you discover that this is what you should have been measuring all along, as opposed to worry about how many hours a person is putting in, you can think about how much value your company is putting *out* instead.

### Not &#8220;Outsourcing&#8221;

Distributed teams have also nothing in common with the practice of &#8220;outsourcing&#8221;, even though that has been associated with an overseas team. WIth outsourcing, you&#8217;re asking another team, who are themselves co-located, just usually in a different country, to do your development task for you. If the development that needs to be done is unimportant or trivial, perhaps that&#8217;s acceptable, but if it&#8217;s core to your business, this always ends badly.

The idea that a project can be shipped overseas and done by the lowest bidder might sometimes work in manufacturing, but software development has almost nothing in common with manufacturing, so it&#8217;s basically a train-wreck, and most companies that have tried understand this by now.

Distributed teams aren&#8217;t the &#8220;cheap&#8221; way of doing a project, and they have nothing to do with lowest-common-denominator thinking.

### Why isn&#8217;t everyone doing it?

Interestingly enough, distributed teams are in fact far more common than most people think, both in the commercial software space and outside it. The vast majority of open source software, for example, is built exclusively by distributed teams, many of whom have never even met each other. Nonetheless they have built some of the most successful software in the world, including the Linux operating system, the Apache web server, and tens of thousands of others.

Industry, however, has been slow to adopt the idea of distributed teams, for a number of reasons. For some it&#8217;s the fear of loss of control, as indeed the management technique for a distributed team is quite different, by necessity. For others it&#8217;s the bad taste in the mouth from the wave of negative &#8220;outsourcing&#8221; experiences, which as we described above really have nothing to do with a distributed team, but the idea of developers who are <i>not</i> physically at your company doing development work gets unfairly mixed in.

### What&#8217;s it Like?

I&#8217;ve worked on and with distributed teams for many years now, and I&#8217;ve seen them done well and I&#8217;ve seen them done poorly.

A distributed team that works is made up of self-starters, developers that know their tools, know their trade, and understand how to deliver value steadily. Someone just learning to program is usually not a good candidate, although it&#8217;s quite possible to introduce beginners into an already successful team.

A critical mindset shift has to take place in any successful distributed team: the group design, communication, interaction and general energy that makes a team a cohesive whole and not just a dissociated group of individuals has to happen *online*.

Usually this takes the form of an online chat mechanism, either with or without audio and video as an adjunct. It can be something as straightforward as irc, which serves as the backbone for many a distributed team, all the way up to more sophisticated solutions like Sqwiggle or iMeet.

With the Apache Foundation, which has been run by distributed teams for many years, there&#8217;s a rule that &#8220;if it didn&#8217;t happen on a mailing list, it didn&#8217;t happen&#8221; &#8211; this simply means that any conversations that don&#8217;t get recorded online in a way that everyone can see them are not to be used for decision-making. For the foundation, the &#8220;place of record&#8221; is the project&#8217;s mailing list. For other remote teams, it&#8217;s been places like Campfire or FlowDock, or a forum like Discourse, but the critical thing is that there is one well-known &#8220;place&#8221; online that every team member, no matter where they are, can see what&#8217;s being talked about, even conversations and/or decisions that happen while they&#8217;re not online.

The tool chosen doesn&#8217;t matter so much as that mind-set, and once everyone on the team makes that transition, it starts to not matter much where people are.

This is often easier in a fully distributed team, e.g. where ever team member is remote from each other, as it becomes a necessity to use on-line communication in any case, so there&#8217;s no opportunity for the team members not &#8220;in the office&#8221; to get left out of the loop.

Once that happens, the remaining tools that a team picks up to share the work are less critical, and the choices that are available today are quite good.

### Tools

A wide array of tools are available for remote development to make the process easier.

It&#8217;s important to start with the basics when selecting tools, and not to try to adopt too much at once. Starting with an online communication system such as IRC and Email at first, then adding other tools as needed.

The Apache foundation has done just fine for decades with little more than a mailing list server as it&#8217;s primary collaboration tool, so it doesn&#8217;t take a complex tool to get started.

#### Source Control

It should go without saying, but any distributed project should select and use a good source control system. By &#8220;good&#8221; I exclude most proprietary systems &#8211; the least you should settle for is SVN, and git or Mercurial would be greatly preferred.

#### Tmux (or Screen)

Beyond the fundamental tools of communications and source control, true real-time pairing needs some kind of collaborative editor or screen-sharing. One of the oldest and most straightforward of such tools is <a href="http://www.gnu.org/software/screen/" target="_new">GNU Screen</a>.

Although it&#8217;s initial purpose was for managing sessions on a single host, another function of screen is to *share* sessions, which is where it&#8217;s potential for remote development comes along.

A more recent derivative of Screen called Tmux is actually used more often today than it&#8217;s predecessor, but the principles are identical.

#### Screen Sharing

Another option more frequently used, but perhaps not as well-suited to the task, is screen-sharing. This is where a tool like VNC or a Javascript-based alternative is used to share all or part of the actual screen output from one system to another. Compared to session sharing with Tmux, this is a relatively bandwidth-heavy process, and can introduce significant lag on connections without sufficient upload bandwidth and speed, especially if combined with VOIP and/or video. It does have the advantage of working with virtually any editor or IDE, however.

Screen-sharing solutions that work in a browser window tend to be a bit slower than the thick-client alternatives, but more convenient. They are particularly useful when quick screen-shares are needed with a non-technical user on the other end. Product demos and such are good examples here, not to much for development pairing.

#### Collaborative Editors

Editors especially designed for collaborative editing, such as SubEthaEdit, are another choice, and have some of their own advantages. Plugins such as Rudel (for Emacs) and Floobits (for vi, Emacs, Sublime Text and others) allow you to have your own editor, and to have it configured as you prefer, while still sharing some editor windows or tabs with your partner. Collaborative editors are a bit similar to Google Docs collaboration.

A hybrid between screen-sharing and collaborative editing is the service/App ScreenHero &#8211; it shares the screen of one person or the other, but both get a cursor, making collaboration easier than having to swap back and forth the &#8220;presenter&#8221;, like other screen-sharing solutions sometimes require.

#### VOIP

Beyond sharing an editor tab or screen, the developers that are pairing need more fluid communications than text chat can provide. Although regular phone is certainly an option (and might be indicated if bandwidth is at a premium), a more popular choice, and one that is even built-in to some solutions, is VOIP (voice-over-I.P.). Typically this involves using a headset for adequate audio quality &#8211; a desktop mic is an option, but the built-in microphone and speakers on most laptops are definitely *not* adequate.

#### Video

Considered superfluous by some developers, the value of video should not be underestimated. Humans communicate a lot with gesture, expression and body language, and adding this valuable channel to the communication between developers can help enormously. I recommend video whenever it is available, unless bandwidth makes it impossible. Some services, such as Sqwiggle, actually provide an &#8220;always-on&#8221; video experience for distributed teams, and this has some merit as well.

Much like audio, an external webcam is often superior to a built-in laptop webcam.

#### Presentation

Over and above the requirements of remote pairing, all of which are nicely met with Tmux or screensharing (plus some form of audio), it&#8217;s often helpful to be able to share the view of a presentation for teaching purposes. Many collaboration solutions include the feature of presenting slides to other parties.

Services such as iMeet have presentation built-in, as do open-source alternatives such as BigBlueButton.

#### Whiteboarding/Diagrams

More valuable than presentations is the ability to share a whiteboard or diagram, as many developers are used to living in very close proximity to a whiteboard.

Even if the particular application you&#8217;re using for collaboration doesn&#8217;t have diagramming build in, apps such as A Web Whiteboard (http://awwapp.com/) can easily be accessed from any browser. Once you share an ID with your pair, you&#8217;re both able to see and edit an online diagram. A Web Whiteboard is more freestyle &#8211; if you need more formal diagrams, LucidCharts or Gliffy might be a better option.

### Time

One element that adds a more complexity than many others is the range of time-zones involved. One or two are no big problem, even three are quite manageable, provided people are willing to stretch their day a few hours one way or another.

Once you get six or more time-zones in the picture, though, you are best served by working fully asynchronously, e.g. to not try to pair in real-time with developers in two different zones. This also means your online text communications must handle asyncronous traffic &#8211; e.g. you might b e better served by something like Discourse, which is a bit more &#8220;forum-like&#8221; and supports threaded discussions than something like Campfire, which is more linear and well suited to realtime or close-to-realtime communications.

Another option is to use more technique and tools for code review, to adjust a bit for the lack of ability to pair in real-time. Tools such as Git pull requests, Gerritt, or Atlassian&#8217;s Crucible are candidates for this area, but they are only an aid, not a real substitute for real-time pairing with VOIP and video.

When you do have to span time-zones, a site like EveryTimeZone (http://everytimezone.com/) can be handy.

## People

The one constant requirement of remote development of any kind is to have the right *people*. Remote development takes a slightly different grade of developer than in-person work does: you need people who have enough skill and experience to be *able* to work on their own (even when they are collaborating). They need to be responsible and self-organizing, as well as having a clear sense of the task at hand and the goals their development are supposed to achieve.

If you add time-zones to the mix, you need even better people &#8211; this is not a task for junior apprentice developers, and is a terrible place to try to save money: If you&#8217;re not paying your remote developers *more* then your in-house people (if you have both), you&#8217;re probably doing it wrong.

This article can&#8217;t do any more than give you a taste of the possibilities of distributed teams, and the tools and techniques for making them work, so we&#8217;ll go into some of the details in future posts.